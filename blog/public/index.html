<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-electron简单使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/19/electron简单使用/" class="article-date">
  <time datetime="2019-11-18T16:00:00.000Z" itemprop="datePublished">2019-11-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/19/electron简单使用/">Electron简单使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Electron是由Github开发，用HTML，CSS和JavaScript来构建跨平台桌面应用程序的一个开源库。</p>
<hr>
<h2 id="Electron简单使用"><a href="#Electron简单使用" class="headerlink" title="Electron简单使用"></a>Electron简单使用</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p> Electron通过将Chromium和Node.js合并到同一个运行时环境中，可以让你使用纯 JavaScript 调用丰富的原生(操作系统) APIs 来创造跨桌面应用。 你可以把它看作一个被 JavaScript 控制的，精简版的 Chromium 浏览器，也可以看做一个 Node. js 的变体，能使用nodejs方法来处理数据，不过专注于桌面应用而不是 Web 服务器端。</p>
<h3 id="2-运行环境"><a href="#2-运行环境" class="headerlink" title="2.运行环境"></a>2.运行环境</h3><p>nodejs，electron开发环境下依赖Node环境，所以需要先安装nodejs，具体参考<a href="https://nodejs.org/" target="_blank" rel="noopener">https://nodejs.org/</a></p>
<h3 id="3-简单使用"><a href="#3-简单使用" class="headerlink" title="3.简单使用"></a>3.简单使用</h3><h4 id="3-1项目结构和启动"><a href="#3-1项目结构和启动" class="headerlink" title="3.1项目结构和启动"></a>3.1项目结构和启动</h4><p>一个简单的electron项目是这样的，package.json 是项目配置文件，electron运行时会通过package.json找到入口文件main.js；而index.html则是electron的主窗口文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app</span><br><span class="line">├── package.json</span><br><span class="line">├── main.js</span><br><span class="line">└── index.html</span><br></pre></td></tr></table></figure></p>
<p>electron安装有全局安装和局部安装两种方式，如果安装过慢，建议使用淘宝镜像代理。全局安装时，项目启动如下，注意点.不好少：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">electron .</span><br></pre></td></tr></table></figure></p>
<p>局部安装启动方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start  //或者node_modules/.bin/electron .</span><br></pre></td></tr></table></figure></p>
<h4 id="3-2项目开发"><a href="#3-2项目开发" class="headerlink" title="3.2项目开发"></a>3.2项目开发</h4><p>Electron apps 使用JavaScript开发，其工作原理和方法与Node.js 开发相同。 electron模块包含了Electron提供的所有API和功能，可以通过require引入使用。electron 模块所提供的功能都是通过命名空间暴露出来的。 比如说： electron.app负责管理Electron 应用程序的生命周期， electron.BrowserWindow类负责创建窗口。</p>
<h6 id="主进程"><a href="#主进程" class="headerlink" title="主进程"></a>主进程</h6><p>一个 Electron 应用只有 一个主进程，即main文件。运行在主进程中的脚本可以通过创建一个窗口，并传入 URL，让这个窗口加载一个网页来展示图形界面。<br>与创建 GUI 相关的接口只应该由主进程来调用。<br>下面是一个main.js文件，编写好index.html文件，即可使用npm start启动项目。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/** main.js */</span><br><span class="line">const &#123; app, BrowserWindow &#125; = require(&apos;electron&apos;);</span><br><span class="line">let mainWindow;</span><br><span class="line">// Electron 会在初始化后并准备</span><br><span class="line">// 创建浏览器窗口时，调用这个函数。</span><br><span class="line">// 部分 API 在 ready 事件触发后才能使用。</span><br><span class="line">app.on(&apos;ready&apos;, () =&gt; &#123;</span><br><span class="line">    mainWindow = new BrowserWindow(&#123;</span><br><span class="line">        width: 1000,</span><br><span class="line">        height: 640,</span><br><span class="line">    &#125;);</span><br><span class="line">    // mainWindow.setMenu(null); // 隐藏Chromium菜单</span><br><span class="line">    // mainWindow.webContents.openDevTools() // 开启调试模式</span><br><span class="line">    var mySocks = &apos;socks5://&apos;+&apos;localhost:1080&apos;;//设置代理</span><br><span class="line">    mainWindow.webContents.session.setProxy(&#123;  // 可以设置翻墙代理</span><br><span class="line">        proxyRules: mySocks,</span><br><span class="line">        proxyBypassRules: `url`//多个用.隔开设置不翻墙ip</span><br><span class="line">    &#125;, function () &#123;</span><br><span class="line">        mainWindow.loadFile(&apos;index.html&apos;); // 主窗口文件引入</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    mainWindow.on(&apos;closed&apos;, () =&gt; &#123;</span><br><span class="line">        mainWindow = null;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">// 忽略证书相关错误</span><br><span class="line">app.commandLine.appendSwitch(&apos;ignore-certificate-errors&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.on(&apos;window-all-closed&apos;, () =&gt; &#123;</span><br><span class="line">    /* 在Mac系统用户通过Cmd+Q显式退出之前，保持应用程序和菜单栏处于激活状态。*/</span><br><span class="line">    if (process.platform !== &apos;darwin&apos;) &#123;</span><br><span class="line">        app.quit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.on(&apos;activate&apos;, () =&gt; &#123;</span><br><span class="line">    /* 当dock图标被点击并且不会有其它窗口被打开的时候，在Mac系统上重新建立一个应用内的window。*/</span><br><span class="line">    if (mainWindow === null) &#123;</span><br><span class="line">        createWindow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h6 id="渲染进程renderer"><a href="#渲染进程renderer" class="headerlink" title="渲染进程renderer"></a>渲染进程renderer</h6><p>在Electron里的每个页面都有它自己的进程，叫作渲染进程。主进程通过实例化 BrowserWindow，每个 BrowserWindow 实例都在它自己的渲染进程内返回一个 web 页面。当 BrowserWindow 实例销毁时，相应的渲染进程也会终止。<br>渲染进程由主进程进行管理。每个渲染进程都是相互独立的，它们只关心自己所运行的 web 页面。一般在对应的html文件的script引入。可以在渲染进程中和主进程进行通信，根据数据渲染更新视图。</p>
<h6 id="主进程main和渲染进程通讯"><a href="#主进程main和渲染进程通讯" class="headerlink" title="主进程main和渲染进程通讯"></a>主进程main和渲染进程通讯</h6><p>主进程和渲染进程通讯有两种方式：<br><strong>1.使用 ipcMain 和 ipcRenderer 模块</strong><br>参照官方文档例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 在主进程中.</span><br><span class="line">const &#123; ipcMain &#125; = require(&apos;electron&apos;)</span><br><span class="line">ipcMain.on(&apos;asynchronous-message&apos;, (event, arg) =&gt; &#123;</span><br><span class="line">  console.log(arg) // prints &quot;ping&quot;</span><br><span class="line">  event.reply(&apos;asynchronous-reply&apos;, &apos;pong&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ipcMain.on(&apos;synchronous-message&apos;, (event, arg) =&gt; &#123;</span><br><span class="line">  console.log(arg) // prints &quot;ping&quot;</span><br><span class="line">  event.returnValue = &apos;pong&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//在渲染器进程 (网页) 中。</span><br><span class="line">const &#123; ipcRenderer &#125; = require(&apos;electron&apos;)</span><br><span class="line">console.log(ipcRenderer.sendSync(&apos;synchronous-message&apos;, &apos;ping&apos;)) // prints &quot;pong&quot;</span><br><span class="line"></span><br><span class="line">ipcRenderer.on(&apos;asynchronous-reply&apos;, (event, arg) =&gt; &#123;</span><br><span class="line">  console.log(arg) // prints &quot;pong&quot;</span><br><span class="line">&#125;)</span><br><span class="line">ipcRenderer.send(&apos;asynchronous-message&apos;, &apos;ping&apos;)</span><br></pre></td></tr></table></figure>
<p>渲染进程通过ipcRenderer向主进程sendSync异步消息synchronous-message，和send同步消息asynchronous-message，主进程使用ipcMain.on监听这两种消息。主进程监听的回调函数中，会传递 event 对象及 arg 对象。arg 对象中保存渲染进程传递过来的参数。通过 event.sender 对象，主进程可以向渲染进程发送消息。如果主进程执行的是同步方法，还可以通过设置 event.returnValue 来返回信息。</p>
<p>主进程向渲染进程发送消息时则需要通过BrowserWindow 对象的webContents 属性，webContets 提供了 send 方法来实现向渲染进程发送消息。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mainWindow.webContents.on(&apos;new-window&apos;, function (event, arg) &#123;</span><br><span class="line">    let childWin = new BrowserWindow(&#123;</span><br><span class="line">        width: 1000,</span><br><span class="line">        height: 640,</span><br><span class="line">    &#125;);</span><br><span class="line">    mainWindow.webContents.send(&apos;ping&apos;, &apos;hhhhh&apos;);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><strong>注： webContents.on只能监听webContents已定义的事件，不能监听自定义事件，监听自定义的事件还是需要ipcMain和ipcRenderer</strong><br>ipcRenderer.on监听主进程传来的消息，也可以通过 event.sender 来向主进程发送消息。这个对象只是 ipcRenderer 的引用(event.sender === ipcRenderer)，还是需要ipcMain.on来接收。<br><strong>2.使用remote（在渲染进程中使用主进程模块）</strong><br>Electron中GUI 相关的模块 (如 dialog、menu 等) 仅在主进程中可用, 在渲染进程中不可用。 为了在渲染进程中使用它们, ipc 模块是向主进程发送进程间消息所必需的。 使用 remote 模块, 你可以调用 main 进程对象的方法, 而不必显式发送进程间消息。<br>注意事项： 因为安全原因，remote 模块能在以下几种情况下被禁用：<br><strong>BrowserWindow - 通过设置 enableRemoteModule 选项为 false。</strong><br><strong>webview - 通过把 enableremotemodule属性设置成 false。</strong><br>如下：在渲染进程创建新窗口打开github。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const &#123; BrowserWindow &#125; = require(&apos;electron&apos;).remote</span><br><span class="line">let win = new BrowserWindow(&#123; width: 800, height: 600 &#125;)</span><br><span class="line">win.loadURL(&apos;https://github.com&apos;)</span><br></pre></td></tr></table></figure></p>
<h6 id="webview"><a href="#webview" class="headerlink" title="webview"></a>webview</h6><p>使用 webview 标签在Electron 应用中嵌入 “外来” 内容 (如 网页)。外来”内容包含在 webview 容器中。 应用中的嵌入页面可以控制外来内容的布局和重绘。<br>(Electron的 webview 标签基于 Chromium webview ，后者正在经历巨大的架构变化。这将影响 webview 的稳定性，包括呈现、导航和事件路由，Electron &gt;= 5禁用 webview 标签。 目前官方建议不使用 webview 标签，并考虑其他替代方案，如 iframe 、Electron的 BrowserView 或完全避免嵌入内容的体系结构。)</p>
<p>使用webview时候只需要在页面中加入该标签，以下是一个简单的webview标签，webview 标签包括网页的 src、控制 webview 容器外观的 css 样式和运行在外来页面的javascript preload.js:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;webview src=&quot;https://github.com/&quot; preload=&quot;./preload.js&quot; style=&quot;display:inline-flex; width:800px; height:640px&quot;&gt;&lt;/webview&gt;</span><br><span class="line"></span><br><span class="line">// preload.js</span><br><span class="line">const ipc = require(&apos;electron&apos;).ipcRenderer;</span><br><span class="line">window.onload = function(event) &#123;</span><br><span class="line">  ipc.on(&apos;answer&apos;, (event, arg) =&gt; &#123;</span><br><span class="line">        console.log(arg);</span><br><span class="line">    &#125;);</span><br><span class="line">	ipc.sendToHost(&apos;pageReady&apos;, true);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>如果要以任何方式控制外来内容, 则可以写用于侦听 webview 事件的 JavaScript, 并使用 webview 方法响应这些事件。 参照官方示例代码: 一个侦听网页开始加载, 另一个用于网页停止加载, 并在加载时显示 “loading…” 消息。也可以在该js中监听上面preload.js的sendToHost事件，或者通过webview.send向preload发送消息，从而使外来页面和webview可以进行通讯：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  onload = () =&gt; &#123;</span><br><span class="line">    const webview = document.querySelector(&apos;webview&apos;)</span><br><span class="line">    const indicator = document.querySelector(&apos;.indicator&apos;)</span><br><span class="line"></span><br><span class="line">    const loadstart = () =&gt; &#123;</span><br><span class="line">      indicator.innerText = &apos;loading...&apos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const loadstop = () =&gt; &#123;</span><br><span class="line">      indicator.innerText = &apos;&apos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    webview.addEventListener(&apos;did-start-loading&apos;, loadstart)</span><br><span class="line">    webview.addEventListener(&apos;did-stop-loading&apos;, loadstop)</span><br><span class="line"></span><br><span class="line">  // webview监听 preload的sendToHost事件</span><br><span class="line">    webview.addEventListener(&apos;ipc-message&apos;, (event) =&gt; &#123;</span><br><span class="line">        if (event.channel === &apos;pageReady) &#123; // channel为事件名称</span><br><span class="line">            console.log(event.args[0]); // event.args[0]为事件所传参数</span><br><span class="line">            webview.send(&apos;answer&apos;, &apos;ok&apos;); //webview.send向preload发送消息</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h6 id="net（使用Chromium的原生网络库发出HTTP-HTTPS请求）"><a href="#net（使用Chromium的原生网络库发出HTTP-HTTPS请求）" class="headerlink" title="net（使用Chromium的原生网络库发出HTTP / HTTPS请求）"></a>net（使用Chromium的原生网络库发出HTTP / HTTPS请求）</h6><p>net 模块是一个发送 HTTP(S) 请求的客户端API。 它类似于Node.js的HTTP 和 HTTPS 模块 ，但它使用的是Chromium原生网络库来替代Node.js的实现，提供更好的网络代理支持。<br><strong>注：只有在应用程序发出 ready 事件之后, 才能使用 net API。尝试在 ready 事件之前使用该模块将抛出一个错误。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const &#123; app &#125; = require(&apos;electron&apos;)</span><br><span class="line">app.on(&apos;ready&apos;, () =&gt; &#123;</span><br><span class="line">  const &#123; net &#125; = require(&apos;electron&apos;)</span><br><span class="line">  const request = net.request(&apos;https://github.com&apos;)</span><br><span class="line">  request.on(&apos;response&apos;, (response) =&gt; &#123;</span><br><span class="line">    console.log(`STATUS: $&#123;response.statusCode&#125;`)</span><br><span class="line">    console.log(`HEADERS: $&#123;JSON.stringify(response.headers)&#125;`)</span><br><span class="line">    let chunks = [];</span><br><span class="line">	let size = 0;</span><br><span class="line">	response.on(&apos;data&apos;, function (chunk) &#123;</span><br><span class="line">		chunks.push(chunk);</span><br><span class="line">		size += chunk.length;</span><br><span class="line">	&#125;);</span><br><span class="line">	response.on(&apos;end&apos;, function () &#123;</span><br><span class="line">		let buf = Buffer.concat(chunks, size);</span><br><span class="line">		let str = iconv.decode(buf, &apos;utf8&apos;); //  iconv转为utf8</span><br><span class="line">		let result = JSON.parse(str);</span><br><span class="line">	&#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  request.end()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="4-打包"><a href="#4-打包" class="headerlink" title="4.打包"></a>4.打包</h3><p>electron有electron-packager及electron-builder两种打包方式。<br>使用electron-packager来进行打包时，可支持平台Windows (32/64 bit)、OS X (also known as macOS)、Linux (x86/x86_64);<br>appname为应用名称，<br>sourcedir为打包目录<br>–arch决定了使用 x86 还是 x64 还是两个架构都用，其中x86位ia32也可以在64位的电脑使用，如果使用ia64则只能在64位的使用。<br>–asar可以把源码打包到一个文件里面，进而获得一定的代码加密和整合的效果<br>ignore ，在将默认打包的范围内，排除掉一些不打包进去的。例如第三方资源文件，是无论如何，都不能打包到asar里面的。打包进去的话，或者没有用，占体积。或者影响程序逻辑实现，不能访问到这些第三方资源。<br>extra-resource，可以将第三方资源，在打包的时候，复制到app.asar的同级目录。<br>–icon决定了应用的图标。<br>–version决定了应用的版本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm run package</span><br><span class="line"></span><br><span class="line">//package.json设置package</span><br><span class="line">&quot;package&quot;: &quot;electron-packager . &lt;appname&gt; --asar --out &lt;sourcedir&gt; --arch=ia32 --version 1.4.0  --icon=./icon.ico  --ignore=res/ --extra-resource=res/&quot;</span><br></pre></td></tr></table></figure></p>
<p>electron-builder就是有比electron-packager有更丰富的的功能，支持更多的平台，同时也支持了自动更新。除了这几点之外，由electron-builder打出的包更为轻量，并且可以打包出不暴露源码的setup安装程序。所以推荐使用electron-builder 。<br>首先，安装依赖。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i electron-builder --save-dev</span><br></pre></td></tr></table></figure></p>
<p>在package.json中做如下配置<br>scripts    npm运行的脚本别名<br>build打包配置<br>icon应用生成的图标<br>target打包成何种应用，如windows打包成exe、tar等，Linux打包成AppImage、snap等<br>category应用分类，固定即可，Linux、Mac上要求的<br>nsis windows下打包nsis时的特有安装参数，如指定可以更改安装目录等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">build&quot;: &#123;</span><br><span class="line">    &quot;win&quot;: &#123;</span><br><span class="line">      &quot;icon&quot;: &quot;icon.png&quot;,</span><br><span class="line">      &quot;target&quot;: [</span><br><span class="line">        &quot;nsis&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;nsis&quot;: &#123;</span><br><span class="line">      &quot;allowToChangeInstallationDirectory&quot;: true,</span><br><span class="line">      &quot;oneClick&quot;: false,</span><br><span class="line">      &quot;menuCategory&quot;: true,</span><br><span class="line">      &quot;allowElevation&quot;: false</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;linux&quot;: &#123;</span><br><span class="line">      &quot;icon&quot;: &quot;icon.png&quot;,</span><br><span class="line">      &quot;category&quot;: &quot;Utility&quot;,</span><br><span class="line">      &quot;target&quot;: [</span><br><span class="line">        &quot;AppImage&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;mac&quot;: &#123;</span><br><span class="line">      &quot;icon&quot;: &quot;icon.png&quot;,</span><br><span class="line">      &quot;type&quot;: &quot;development&quot;,</span><br><span class="line">      &quot;category&quot;: &quot;public.app-category.developer-tools&quot;,</span><br><span class="line">      &quot;target&quot;: [</span><br><span class="line">        &quot;dmg&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;build:linux&quot;: &quot;node_modules/.bin/electron-builder -l&quot;,</span><br><span class="line">    &quot;build:windows&quot;: &quot;node_modules/.bin/electron-builder -w&quot;,</span><br><span class="line">    &quot;build:mac&quot;: &quot;node_modules/.bin/electron-builder -m&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>以上是个人简单使用了一段时间electron后了解到的知识，记录下来弄了个简单的使用指南，如有错误欢迎指正。现阶段使用的是electron4.04版本，版本升级后可能有其它方法使用需校正。具体还以官网文档为准。<a href="https://electronjs.org/docs" title="electron文档" target="_blank" rel="noopener">electron文档</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/19/electron简单使用/" data-id="ck35rvnxs0000jwm17sqqcmji" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-vue单元测试简单使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/11/vue单元测试简单使用/" class="article-date">
  <time datetime="2017-10-10T16:00:00.000Z" itemprop="datePublished">2017-10-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/11/vue单元测试简单使用/">Vue单元测试简单使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>单元测试，在维基百科中解释是：在计算机编程中，单元测试（英语：Unit Testing）又称为模块测试, 是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。 程序单元是应用的最小可测试部件。 在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。而vue单元测试在我看来就是为了隔离应用部件并证明这些单个vue组件是正确的，以在开发过程的早期就能发现问题，提高代码质量和可维护性，从而有效的减少维护成本，降低 Bug 率。</p>
<hr>
<h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h2><p>整理一下配置测试环境所需要的依赖：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">karma <span class="comment">//test runner，提供测试所需的浏览器环境、监测代码改变自动重测、整合持续集成等功能</span></span><br><span class="line">phantomjs-prebuilt <span class="comment">//phantomjs，在终端运行的浏览器虚拟机，也可以直接使用了chrome</span></span><br><span class="line">mocha <span class="comment">//test framework，测试框架，运行测试</span></span><br><span class="line">chai <span class="comment">//assertion framework, 断言库，提供多种断言，与测试框架配合使用</span></span><br><span class="line">sinon <span class="comment">//测试辅助工具，提供 spy、stub、mock 三种测试手段，帮助捏造特定场景</span></span><br><span class="line">karma-webpack <span class="comment">//karma 中的 webpack 插件， 连接karma和webpack的桥梁。不经过webpack编译命令是文件是无法独立运行的，karma需要了解你的webpack配置，决定如何处理你的测试文件。</span></span><br><span class="line">karma-mocha <span class="comment">//在karma 中使用 mocha测试框架的 插件</span></span><br><span class="line">karma-sinon-chai <span class="comment">//在karma 中使用 sinon-chai断言库的 插件</span></span><br><span class="line">sinon-chai <span class="comment">//karma 中的 chai 插件</span></span><br><span class="line">karma-sourcemap-loader <span class="comment">//karma 中的 sourcemap 插件</span></span><br><span class="line">karma-phantomjs-launcher <span class="comment">//karma 中的 phantomjs 插件,如使用chrome为测试浏览器则为karma-chrome-launcher</span></span><br><span class="line">karma-spec-reporter <span class="comment">//在终端输出测试结果的插件</span></span><br><span class="line">karma-coverage <span class="comment">//代码覆盖率统计工具coverage</span></span><br></pre></td></tr></table></figure></p>
<p>要在karma使用某个测试工具都需要安装karma对应的插件。<br>相关配置安装一波<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i karma mocha chai sinon karma-webpack karma-mocha karma-sinon-chai sinon-chai karma-sourcemap-loader karma-chrome-launcher karma-spec-reporter karma-coverage --save-dev</span><br></pre></td></tr></table></figure></p>
<p>安装好了，可以先跑一下看看是否安装正确，到package.json的scripts中注册一个命令：”unit”: “cross-env BABEL_ENV=test karma start karma.conf.js –single-run”，然后运行。</p>
<h2 id="2-配置-karma"><a href="#2-配置-karma" class="headerlink" title="2. 配置 karma"></a>2. 配置 karma</h2><p>按照 karma 的文档，运行：karma init。因为karma是要在命令中运行的，所以需要先安装karma-cli：npm install -g karma-cli。这时可以选择使用的测试框架、是否使用 require.js、浏览器环境、测试脚本存放位置、是否有需要 ignore 的文件，等等。选择完毕之后，该项目根目录下生成名为 karma.conf.js 文件。<br>修改Karma配置：<br>打开karma.config.js文件，引入webpack，并配置webpack加载 .js、.vue、babel；这和普通的 webpack 配置没什么差别，除了 entry 之外，resolve、各种 loader 等等都需要加上.<br>最终的karma配置如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Karma configuration</span></span><br><span class="line"><span class="keyword">var</span> webpack= <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">var</span> path= <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">    config.set(&#123;</span><br><span class="line">        <span class="comment">// 文件匹配的起始路径</span></span><br><span class="line">        basePath: <span class="string">''</span>,</span><br><span class="line">        <span class="comment">// 测试框架</span></span><br><span class="line">        <span class="comment">// available frameworks: 	https://npmjs.org/browse/keyword/karma-adapter</span></span><br><span class="line">        frameworks: [<span class="string">'mocha'</span>,<span class="string">'chai'</span>],</span><br><span class="line">        <span class="comment">// 要测试的目标文件</span></span><br><span class="line">        files: [</span><br><span class="line">            <span class="string">'test/unit/**/*.spec.js'</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">// 忽略的文件</span></span><br><span class="line">        exclude: [</span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">// 预处理文件</span></span><br><span class="line">        <span class="comment">// available preprocessors: 	https://npmjs.org/browse/keyword/karma-preprocessor</span></span><br><span class="line">        preprocessors: &#123;</span><br><span class="line">            <span class="string">'test/unit/**/*.spec.js'</span>:[<span class="string">'webpack'</span>,<span class="string">'coverage'</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//karma的watch模式,即自动化测试</span></span><br><span class="line">        autoWatch:<span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 测试报告处理</span></span><br><span class="line">        <span class="comment">// available reporters: 		https://npmjs.org/browse/keyword/karma-reporter</span></span><br><span class="line">        reporters: [<span class="string">'spec'</span>,<span class="string">'progress'</span>,<span class="string">'coverage'</span>],</span><br><span class="line">        /测试覆盖率文件输出</span><br><span class="line">        coverageReporter: &#123;</span><br><span class="line">            type: <span class="string">'html'</span>,</span><br><span class="line">            dir: <span class="string">'test/coverage/'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 服务器端口</span></span><br><span class="line">        port: <span class="number">9876</span>,</span><br><span class="line">        <span class="comment">// 输出着色</span></span><br><span class="line">        colors: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 日志级别</span></span><br><span class="line">        <span class="comment">// LOG_DISABLE || LOG_ERROR || LOG_WARN || LOG_INFO || LOG_DEBUG</span></span><br><span class="line">        logLevel: config.LOG_INFO,</span><br><span class="line">        <span class="comment">//监控文件更改</span></span><br><span class="line">        autoWatch: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 要启动的测试浏览器</span></span><br><span class="line">        <span class="comment">// available browser launchers: 		https://npmjs.org/browse/keyword/karma-launcher</span></span><br><span class="line">        browsers: [<span class="string">'Chrome'</span>],</span><br><span class="line">        <span class="comment">// true: 自动运行测试并退出</span></span><br><span class="line">        <span class="comment">// false: 监控文件持续测试</span></span><br><span class="line">        singleRun: <span class="literal">false</span>,</span><br><span class="line">        <span class="comment">// Concurrency level</span></span><br><span class="line">        <span class="comment">// how many browser should be started simultaneous</span></span><br><span class="line">        concurrency: <span class="literal">Infinity</span>,</span><br><span class="line">        <span class="comment">// 超时处理，6s内没有捕获浏览器将终止进程</span></span><br><span class="line">        <span class="comment">// captureTimeout: 6000</span></span><br><span class="line">        <span class="comment">// 手动引入 karma 的各项插件，如果不显式引入，karma 也会自动寻找 karma- 开	头的插件并自动引入</span></span><br><span class="line">        <span class="comment">//plugins: [],</span></span><br><span class="line">        <span class="comment">// webpack</span></span><br><span class="line">        webpack: &#123;</span><br><span class="line">            <span class="built_in">module</span>: &#123;</span><br><span class="line">                loaders: [</span><br><span class="line">                &#123;</span><br><span class="line">                    test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">                    loader: <span class="string">'vue'</span></span><br><span class="line">                &#125;,&#123;</span><br><span class="line">                    test: <span class="regexp">/\.(sass|scss|css)$/</span>,</span><br><span class="line">                    loaders: [<span class="string">'style'</span>, <span class="string">'css'</span>, <span class="string">'sass'</span>]</span><br><span class="line">                &#125;,&#123;</span><br><span class="line">                    test: <span class="regexp">/\.(woff|woff2|eot|ttf|svg)/</span>,</span><br><span class="line">                    loader: <span class="string">'file?name=fonts/[name].[ext]'</span></span><br><span class="line">                &#125;,&#123;</span><br><span class="line">                    test: <span class="regexp">/algeria\.json/</span>,</span><br><span class="line">                    loader: <span class="string">'file?name=[name].[ext]'</span></span><br><span class="line">                &#125;,&#123;</span><br><span class="line">                    test: <span class="regexp">/sigma/</span>,</span><br><span class="line">                    loader: <span class="string">'imports-loader?this=&gt;window'</span></span><br><span class="line">                &#125;,&#123;</span><br><span class="line">                    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                    loader: <span class="string">'babel?cacheDirectory=.babel_cache'</span>,</span><br><span class="line">                    exclude:<span class="regexp">/libs|node_modules|vue\/dist|vue-router\/|vue-loader\/|vue-hot-reload-api\//</span></span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;,</span><br><span class="line">            vue: &#123;</span><br><span class="line">                loaders: &#123;</span><br><span class="line">                    js: <span class="string">'babel?cacheDirectory=.babel_cache'</span>,</span><br><span class="line">                    css: <span class="string">'vue-style!css'</span>,</span><br><span class="line">                    sass: <span class="string">'vue-style!css!sass'</span>,</span><br><span class="line">                    scss: <span class="string">'vue-style!css!sass'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            resolve: &#123;</span><br><span class="line">                extensions: [<span class="string">''</span>, <span class="string">'.js'</span>, <span class="string">'.vue'</span>],</span><br><span class="line">                modulesDirectories: [<span class="string">'node_modules'</span>],</span><br><span class="line">                alias: &#123;</span><br><span class="line">                    vue: <span class="string">'vue/dist/vue.js'</span>, <span class="comment">// independent render,</span></span><br><span class="line">                    scss: path.resolve(__dirname, <span class="string">'./src/scss'</span>),</span><br><span class="line">                    mixins: path.resolve(__dirname, <span class="string">'src'</span>, <span class="string">'mixins'</span>),</span><br><span class="line">                    components: path.resolve(__dirname, <span class="string">'src'</span>, <span class="string">'components'</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-规划目录结构"><a href="#3-规划目录结构" class="headerlink" title="3.规划目录结构"></a>3.规划目录结构</h2><p>├── src/<br>│<br>├── test/<br>     └── coverage/<br>│   └── unit/<br>│       └── *.spec.js<br>└── karma.conf.js<br>测试的项目源代码主要处于src中。测试相关文件均放在 test/unit 文件夹下，各个组件的单元测试文件分别为 组件名.spec.js。coverage文件夹是运行命令后自动生成的覆盖率文件夹，它默认产生在项目目录下的，这里为了不影响项目代码结构，我把karma.config.js文件里的coverageReporter生成路径修改为了“test/coverage/”，让它在test文件下生成。</p>
<h2 id="4-编写组件测试代码"><a href="#4-编写组件测试代码" class="headerlink" title="4.编写组件测试代码"></a>4.编写组件测试代码</h2><p>在编写测试代码前，简单介绍下测试框架mocha和断言chai。</p>
<h3 id="Mocha"><a href="#Mocha" class="headerlink" title="Mocha"></a>Mocha</h3><p><a href="http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html</a><br>mocha编写的测试用例主要由describe和it组成。测试脚本里面应该包括一个或多个describe块，每个describe块应该包括一个或多个it块。 describe块称为”测试套件”（test suite），表示一组相关的测试。它是一个函数，第一个参数是测试套件的名称，第二个参数是一个实际执行的函数。 it块称为”测试用例”，表示一个单独的测试，是测试的最小单位。它也是一个函数，第一个参数是测试用例的名称，第二个参数是一个实际执行的函数。如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'new-thumbnail'</span>, () =&gt; &#123;</span><br><span class="line">    it(<span class="string">'create'</span>, done =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>由于Vue进行异步更新DOM的情况，一些依赖DOM更新结果的断言必须在 Vue.nextTick 回调中进行：并且需要在it语句传入done，在回调结束的时候执行done().如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'test computed'</span>, done =&gt; &#123;</span><br><span class="line">    Vue.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        expect(vm.visible).to.equal(<span class="literal">true</span>);</span><br><span class="line">        done()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>mocha在describe块之中，提供测试用例的四个钩子：before()、after()、beforeEach()和afterEach()。它们会在指定时间执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'hook'</span>, () =&gt; &#123;</span><br><span class="line">    before(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在本区块的所有测试用例之前执行</span></span><br><span class="line">    &#125;)</span><br><span class="line">    after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 在本区块的所有测试用例之后执行</span></span><br><span class="line">    &#125;)</span><br><span class="line">    beforeEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 在本区块的每个测试用例之前执行</span></span><br><span class="line">    &#125;)</span><br><span class="line">    afterEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 在本区块的每个测试用例之前执行</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="Chai"><a href="#Chai" class="headerlink" title="Chai"></a>Chai</h3><p><a href="http://chaijs.com/api/" target="_blank" rel="noopener">http://chaijs.com/api/</a><br>所谓”断言”，就是判断源码的实际执行结果与预期结果是否一致，如果不一致就抛出一个错误。这里用的断言库是chai，其中有三个API expect/should/assert，比较常用的是expect。详细可以看chai的相关api。如下面的这句断言意思就是vm.visible的值应该是true。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(vm.visible).to.equal(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>主要就是在unit文件夹下建立对应组件的*.spec.js文件，并在该文件中写各种测试用例，开始时首先需要在文件头引入组件所引用的各种依赖，如组件中使用了element组件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">'element-ui'</span></span><br><span class="line">Vue.use(ElementUI);</span><br></pre></td></tr></table></figure></p>
<p>1.一般组件的测试可以直接使用定义好的createTest工具函数（见5）来直接创建测试组件实例，然后就可以对实例进行模拟操作，断言其期望值是否达到预期。不符合的话，会在控制台输出相应的错误，从而了解到该方法不能达到预期，存在着问题。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vm = createTest(NewThumbnail, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'测试组件detail.vue不涉及store的methods'</span>, () =&gt; &#123; </span><br><span class="line">    it(<span class="string">'test methods without store'</span>, done =&gt;&#123;</span><br><span class="line">        expect(<span class="literal">true</span>).to.equal(<span class="literal">false</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><img src="https://leefenghuo.github.io/images/error.png" alt="error"></p>
<p>2.如果组件应用到store进行状态管理，则需要引入store文件，可在创建测试组件实例构造器Vue.extend时传入store，才能在测试实例中使用。在测试detail组件中，打开不同模块的详情都需要调用store里的 showDetail mutation，并传入不同的参数。为了能在测试不同详情信息的输入结果是否达到预期，我一般都选择在每个describe块的before钩子函数进行commint。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个传入store的vue组件构造函数</span></span><br><span class="line"><span class="keyword">var</span> ctsr=Vue.extend(&#123;</span><br><span class="line">    store</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> vm= <span class="keyword">new</span> ctsr(detail); </span><br><span class="line"></span><br><span class="line"><span class="comment">//moduleType:'program' </span></span><br><span class="line">describe(<span class="string">'moduleType为program时detail.vue methods'</span>, () =&gt; &#123; </span><br><span class="line">    before(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 在本区块的所有测试用例之前执行</span></span><br><span class="line">        vm.$store.commit(<span class="string">'showDetail'</span>,&#123;</span><br><span class="line">            id:<span class="string">'program1'</span>,</span><br><span class="line">            rowData:&#123;<span class="string">'a'</span>: <span class="number">1</span>&#125;,</span><br><span class="line">            moduleType:<span class="string">'program'</span>,</span><br><span class="line">            hasButton:<span class="literal">true</span>,</span><br><span class="line">            processAuth:<span class="string">'va.video.programGetEvidence.search.detail.process'</span>,</span><br><span class="line">            createWritAuth:<span class="string">'va.video.programGetEvidence.search.detail.createWri'</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>3.如测试的组件涉及到异步ajax请求，可以安装mockJs，使用mockJs来拦截请求，并返回一些模拟数据，来判断数据是否达到预期。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Mock.mock(<span class="string">"/hawkeye/va/video/programMonitor/processall"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">"code"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">"msg"</span>: <span class="string">"节目直接处理"</span>,</span><br><span class="line">        <span class="string">"data"</span>: &#123;</span><br><span class="line">          <span class="string">"status"</span>: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>4.测试结果查看：测试结果主要在终端查看，可以看到相关的断言是否正确。如配置了coverage插件，则会在相应的目录下生产coverage文件夹，具体的目录结果如下：打开index.html文件即可查看到代码的覆盖率等相关信息。<br><img src="https://leefenghuo.github.io/images/success.png" alt="coverage"><br><img src="https://leefenghuo.github.io/images/file.png" alt="coverage"><br>但是我发现打开的index文件这里的detail.spec.js，默认是编译之后的文件，所以，测试覆盖率就是打包编译后的覆盖率，这并不是我想要的。<br><img src="https://leefenghuo.github.io/images/coverage1.png" alt="coverage"><br><img src="https://leefenghuo.github.io/images/coverage2.png" alt="coverage"><br>经过网上的查找之后，发现需要另外另外安装两个模块：sourcemap 与 isparta,去掉karma.comfig.js里面的preprocessors中的coverage设置，同时需要修改vue的js loader。<br>sourcemap 是资源定位的模块<br>isparta 计算测试覆盖率</p>
<p>npm install –save-dev sourcemap isparta isparta-loader<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预处理文件</span></span><br><span class="line"><span class="comment">// available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor</span></span><br><span class="line">preprocessors: &#123;</span><br><span class="line">    <span class="string">'test/unit/**/*.spec.js'</span>:[<span class="string">'webpack'</span>]</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">vue: &#123;</span><br><span class="line">loaders: &#123;</span><br><span class="line">    js: <span class="string">'isparta-loader'</span>,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">isparta: &#123;</span><br><span class="line">    emBedSource: <span class="literal">true</span>,</span><br><span class="line">    noAutoWrap: <span class="literal">true</span>,</span><br><span class="line">    babel: &#123;</span><br><span class="line">        presets: [<span class="string">'es2015'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>再运行测试命令，这时打开index.html，显示如下：<br><img src="https://leefenghuo.github.io/images/coverage3.png" alt="coverage"><br><img src="https://leefenghuo.github.io/images/coverage4.png" alt="coverage"><br>detail.vue即是要测试的组件，该文件中代码部分按照“绿色”，“黄色”和“红色”进行分类。“绿色”表示没有静态错误的代码；“黄色”表示可能存在错误的代码，需要重新测试；“红色”表示肯定没有测试到的代码。这样，我可以集中精力编写“红色”代码测试，重点测试“黄色”代码。<br><img src="https://leefenghuo.github.io/images/code_yellow.png" alt="coverage"><br><img src="https://leefenghuo.github.io/images/code_red.png" alt="coverage"><br>5.在编写测试代码过程，可以直接参考了ElementUi组件库测试的一个工具函数做了简单的修改，在test文件夹新建了一个util.js的文件来存放几个工具函数，辅助生成测试组件实例。如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个 Vue 的实例对象</span></span><br><span class="line"><span class="comment"> * @param  &#123;Object|String&#125;  Compo   组件配置，可直接传 template</span></span><br><span class="line"><span class="comment"> * @param  &#123;Boolean=false&#125; mounted 是否添加到 DOM 上</span></span><br><span class="line"><span class="comment"> * @return &#123;Object&#125; vm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">exports.createVue = <span class="function"><span class="keyword">function</span>(<span class="params">Compo, mounted = false</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(Compo) === <span class="string">'[object String]'</span>) &#123;</span><br><span class="line">    Compo = &#123; <span class="attr">template</span>: Compo &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Vue(Compo).$mount(mounted === <span class="literal">false</span> ? <span class="literal">null</span> : createElm());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个测试组件实例</span></span><br><span class="line"><span class="comment"> * @link http://vuejs.org/guide/unit-testing.html#Writing-Testable-Components</span></span><br><span class="line"><span class="comment"> * @param  &#123;Object&#125;  Compo          - 组件对象</span></span><br><span class="line"><span class="comment"> * @param  &#123;Object&#125;  propsData      - props 数据</span></span><br><span class="line"><span class="comment"> * @param  &#123;Boolean=false&#125; mounted  - 是否添加到 DOM 上</span></span><br><span class="line"><span class="comment"> * @return &#123;Object&#125; vm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">exports.createTest = <span class="function"><span class="keyword">function</span>(<span class="params">Compo, propsData = &#123;&#125;, mounted = false</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (propsData === <span class="literal">true</span> || propsData === <span class="literal">false</span>) &#123;</span><br><span class="line">    mounted = propsData;</span><br><span class="line">    propsData = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> elm = createElm();</span><br><span class="line">  <span class="keyword">const</span> Ctor = Vue.extend(Compo);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Ctor(&#123; propsData &#125;).$mount(mounted === <span class="literal">false</span> ? <span class="literal">null</span> : elm);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过 createTest 和 createVue 两个函数就可以很灵活的生成.vue这种单文件组件和自定义标签的组件的 Vue 实例，然后模拟各种操作来执行单元测试。另外还有模拟鼠标、键盘点击事件triggerEvent/triggerClick的也放在了util.js里。</p>
<h2 id="5-结语"><a href="#5-结语" class="headerlink" title="5.结语"></a>5.结语</h2><p>由于本人第一次接触vue单元测试，在编写测试代码的过程中都是摸索着写的，有写的不对的地方，欢迎大家批评指正，多多指导。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/11/vue单元测试简单使用/" data-id="ck35rvny00001jwm1oyktkd6h" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/11/19/electron简单使用/">Electron简单使用</a>
          </li>
        
          <li>
            <a href="/2017/10/11/vue单元测试简单使用/">Vue单元测试简单使用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>